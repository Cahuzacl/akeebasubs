Validator Unit Test queue
========================================================================================================================
AkpaymentBase::fixSubscriptionDates

Note: $subscription->params['fixdates'] holds our information. Keys: oldsub, expiration, allsubs

[UID 2000]

√ No fixdates keys. No old subscription, publish_up in the past
√ No fixdates keys. No old subscription, publish_up now
√ No fixdates keys. No old subscription, publish_up in the future

No fixdates, forever/fixed date subscription

XXX [UID 2010]

No fixdates keys. Existing subscription in the same level (expired), publish_up in the past
No fixdates keys. Existing subscription in the same level (expired), publish_up now
No fixdates keys. Existing subscription in the same level (expired), publish_up in the future

XXX [UID 2020]

No fixdates keys. Existing subscription in the same level (active), publish_up in the past
No fixdates keys. Existing subscription in the same level (active), publish_up now
No fixdates keys. Existing subscription in the same level (active), publish_up in the future

XXX [UID 2030]

No fixdates keys. Existing subscription in another level (active), publish_up in the past
No fixdates keys. Existing subscription in another level (active), publish_up now
No fixdates keys. Existing subscription in another level (active), publish_up in the future

[UID 2000]

√ oldsub is null. publish_up in the past.
√ oldsub is null and expiration=replace (downgraded to overlap). publish_up in the past.
√ oldsub is null and expiration=after (downgraded to overlap). publish_up in the past.
√ oldsub does not exist. publish_up in the past.

√ expiration = replace

    √ [UID 2010]

    oldsub in the same level (active), publish_up in the past
    oldsub in the same level (active), publish_up now
    oldsub in the same level (active), publish_up in the future

    √ [UID 2030]

    oldsub in another level (active), publish_up in the past
    oldsub in another level (active), publish_up now
    oldsub in another level (active), publish_up in the future

    √ [UID 2040]

    oldsub in the same level (active), allsubs in mixed levels (active & expired), publish_up in the past
    oldsub in the same level (active), allsubs in mixed levels (active & expired), publish_up now
    oldsub in the same level (active), allsubs in mixed levels (active & expired), publish_up in the future

expiration = after

    √ [UID 2010]

    √ oldsub in the same level (active), publish_up in the past
    √ oldsub in the same level (active), publish_up now
    √ oldsub in the same level (active), publish_up in the future

    [UID 2030]

    oldsub in another level (active), publish_up in the past
    oldsub in another level (active), publish_up now
    oldsub in another level (active), publish_up in the future

    [UID 2040]

    oldsub in the same level (active), allsubs in mixed levels (active & expired), publish_up in the past
    oldsub in the same level (active), allsubs in mixed levels (active & expired), publish_up now
    oldsub in the same level (active), allsubs in mixed levels (active & expired), publish_up in the future




subs (S1 is the target sub)
    array of
        level
        publish_up
        fixdates
            oldsub
            expiration
            allsubs
expected
message


Subscriptions (level, user_id, enabled):
	2010, 100, 0

	2020, 100, 1

	2030, 200, 1

	2040, 100, 0
	2040, 100, 1
	2040, 100, 1 - future
	2040, 200, 0
	2040, 200, 1
	2040, 200, 1 – future



Refactor Subscribe model, step 5

    At subscription time
        Subscription length or end date
            [
                'duration' => null or integer (number of seconds)
                'publish_down' => null or integer (UNIX timestamp)
            ]
            If not fixed or forever get duration from the level and the onValidateSubscriptionLength plugins
            If fixed/forever set publish_down instead

        Subscription start time
            [
                'publish_up' => integer (UNIX timestamp)
                'noContact' => []
            ]
            Default now
            Check if there are more subscriptions in the same level or group
            Add all found subscription IDs to the noContact array
            Set the start date to the greatest subscription expiration + 1 second

        Merge the two arrays:
            [
                'publish_up' => integer (UNIX timestamp)
                'publish_down' => integer
                'noContact' => []
            ]

        The noContact array must be added to the params['fixdates'] array
